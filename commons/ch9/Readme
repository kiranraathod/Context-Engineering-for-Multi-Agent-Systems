
  Token optimization displayed with two upgrades:
  1.The Execution Engine (to calculate and store the counts)
  1.1. In `engine.py`

Token optimization displayed with two upgrades:

1. The Execution Engine (to calculate and store the counts)  
1.1. In `engine.py`

### UPGRADE: Now accepts token metrics
```python
def log_step(self, step_num, agent, planned_input, mcp_output, resolved_input, tokens_in=0, tokens_out=0):
    self.steps.append({
        "step": step_num,
        "agent": agent,
        "planned_input": planned_input,
        "resolved_context": resolved_input,
        "output": mcp_output['content'],
        "tokens_in": tokens_in,
        "tokens_out": tokens_out,
        "tokens_saved": max(0, tokens_in - tokens_out) if agent == "Summarizer" else 0
    })


2. Inside the def context_engine(...)
 # 1. Resolve inputs
            resolved_input = resolve_dependencies(planned_input, state)
            
            # UPGRADE: Count Input Tokens (The context being sent to the agent)
            t_in = count_tokens(str(resolved_input))
            
            # 2. Call the agent
            mcp_resolved_input = create_mcp_message("Engine", resolved_input)
            mcp_output = handler(mcp_resolved_input)
            output_data = mcp_output["content"]
            
            # UPGRADE: Count Output Tokens (The response generated by the agent)
            t_out = count_tokens(str(output_data))
            
            # 3. Update state and log results
            state[f"STEP_{step_num}_OUTPUT"] = output_data
            
            # UPGRADE: Pass token counts into the log_step call
            trace.log_step(
                step_num, 
                agent_name, 
                planned_input, 
                mcp_output, 
                resolved_input, 
                tokens_in=t_in, 
                tokens_out=t_out
            )
            
            logging.info(f"--- Executor: Step {step_num} completed. ---")

